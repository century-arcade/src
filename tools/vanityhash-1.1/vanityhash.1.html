<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>vanityhash - A hex hash fragment creation tool</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#options">OPTIONS</a></li>
	<li><a href="#bugs___limitations">BUGS / LIMITATIONS</a></li>
	<li><a href="#credits">CREDITS</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>vanityhash - A hex hash fragment creation tool</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p><strong>vanityhash</strong> [&nbsp;<strong>options</strong>&nbsp;] hexfragment &lt; inputfile</p>
<p><strong>vanityhash</strong> <strong>--append</strong> [&nbsp;<strong>options</strong>&nbsp;] hexfragment &lt; inputfile &gt; outputfile</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p><strong>vanityhash</strong> is a tool that can discover data to be added to the end 
of a file to produce a desired hex hash fragment.  It searches a 
message space and runs a hashing algorithm against the original data 
plus the appended data to determine if the desired hash fragment is 
present.  vanityhash can run multiple parallel workers to effectively 
make use of multiple processors/cores/threads, and supports multiple 
hash digest types (MD5, SHA1, SHA256, etc).</p>
<p>vanityhash can be used to append data to files that are capable of 
ignoring garbage data at the end of the file (such as ISO images and 
some types of graphic images), in order to produce a &quot;vanity&quot; hash.  
vanityhash is fast, as it only reads the base input data once, and then 
reverts back to that base state over and over while it permeates the 
search space, rather than hashing the entire source during each 
permeation.</p>
<p>vanityhash operates on the concept of a &quot;search space&quot;.  For example, 
given a 24-bit search space, vanityhash will run from 0x00000000 to 
0x00ffffff, append the 4-byte packed version of each number to the end 
of the input data, calculate the resulting hash, and search the hash 
value for the desired hex fragment pattern.  A desired hex fragment can 
be larger than the search space (for example, searching for &quot;abcdef&quot; in 
a 16-bit search space), but the chances of finding a match reduce 
drastically the larger the desired hex fragment is.</p>
<p>In its default operation, vanityhash will search the entire specified 
search space and output all matching results to STDOUT, one result per 
line, in the form &quot;extradata hash&quot;, where both &quot;extradata&quot; and &quot;hash&quot; 
are in hex form.  When the <strong>--append</strong> option is specified, this 
behavior changes.  If a match is found, the original input data plus 
the extra data (in byte form) are outputted, and searching ends after 
the first successful match.  If no matches are found, the original data 
only is outputted.</p>
<p>
</p>
<hr />
<h1><a name="options">OPTIONS</a></h1>
<dl>
<dt><strong><a name="b_bits_bits_bits" class="item"><strong>-b</strong> <em>bits</em>, <strong>--bits</strong>=<em>bits</em></a></strong></dt>

<dd>
<p>Space to be searched, in bits.  Allowed values range from 1 to 64.  
Default is 24.  Search spaces larger than 32 bits require a 64-bit 
operating system, and a version of Perl compiled with 64-bit integer 
support.</p>
</dd>
<dt><strong><a name="p_position_position_position" class="item"><strong>-p</strong> <em>position</em>, <strong>--position</strong>=<em>position</em></a></strong></dt>

<dd>
<p>The position within the hex hash to look for the desired fragment, in 
hex digits.  The beginning starts at 0.  Default is 0.  A position that 
extends the fragment beyond the length of the hash is not allowed.</p>
</dd>
<dt><strong><a name="y_any_position" class="item"><strong>-y</strong>, <strong>--any-position</strong></a></strong></dt>

<dd>
<p>When enabled, this option will override <strong>--position</strong> and will return 
hashes that contain the desired fragment in any position within the 
hash.</p>
</dd>
<dt><strong><a name="s_seconds_progress_seconds" class="item"><strong>-s</strong> <em>seconds</em>, <strong>--progress</strong>=<em>seconds</em></a></strong></dt>

<dd>
<p>The number of seconds between printing of progress lines, default 5 
seconds.  A decimal value may be specified.  A value of 0 disabled 
printing progress lines.</p>
</dd>
<dt><strong><a name="w_workers_workers_workers" class="item"><strong>-w</strong> <em>workers</em>, <strong>--workers</strong>=<em>workers</em></a></strong></dt>

<dd>
<p>The number of workers to be spawned.  Default is 1.  Recommended value 
is the number of logical processors on the running system.</p>
</dd>
<dt><strong><a name="d_digesttype_digest_digesttype" class="item"><strong>-d</strong> <em>digesttype</em>, <strong>--digest</strong>=<em>digesttype</em></a></strong></dt>

<dd>
<p>The hashing digest type to use.  Default is &quot;md5&quot; Allowed values are 
&quot;md2&quot;, &quot;md4&quot;, &quot;md5&quot;, and &quot;sha<em>N</em>&quot; where <em>N</em> is a valid SHA digest 
value.  &quot;sha1alt&quot; is accepted to use Digest::SHA1 instead of 
Digest::SHA.  Note that for many digest types, the appropriate Perl 
module must be installed and available.</p>
</dd>
<dt><strong><a name="a_append" class="item"><strong>-a</strong>, <strong>--append</strong></a></strong></dt>

<dd>
<p>When enabled, the original data is outputted back to STDOUT.  Then, 
when/if the first matching hash is found, the data fragment used to 
produce the matching hash is outputted to STDOUT.  STDOUT can then be 
redirected to another file to produce the modified file.</p>
</dd>
<dt><strong><a name="q_quiet" class="item"><strong>-q</strong>, <strong>--quiet</strong></a></strong></dt>

<dd>
<p>Normally vanityhash sends a fair amount of status information to STDERR 
during operation.  When enabled, all non-error status information is 
instead suppressed.</p>
</dd>
<dt><strong><a name="help" class="item"><strong>-?</strong>, <strong>--help</strong></a></strong></dt>

<dd>
<p>Print a synposis and exit.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="bugs___limitations">BUGS / LIMITATIONS</a></h1>
<p>Search spaces larger than 32 bits require a 64-bit operating system, 
and a version of Perl compiled with 64-bit integer support.</p>
<p>A block of computed data is added equal to the size of the integer type 
the search space fits into (1 byte for 8 bits or less, 2 bytes for 9 
through 16 bits, 4 bytes for 17 through 32 bits, 8 bytes for 33 through 
64 bits), even if the search space could fit into a smaller raw byte 
block (say, 3 bytes for a 20-bit search space).  While this does not 
reduce (or increase) the possibility of finding a match in a given 
search space, the extra null byte(s) in the block are technically 
wasteful.</p>
<p>Extra bytes are packed according to system endianness.  Thus, search 
results will be different between big and little endian systems.</p>
<p>vanityhash should work fine on any POSIX operating system, and has been 
tested on Linux and Mac OS X.  It mostly works with Strawberry Perl for 
Windows, but crashes at the end.  Suggestions to fix this would be 
welcomed.</p>
<p>
</p>
<hr />
<h1><a name="credits">CREDITS</a></h1>
<p><strong>vanityhash</strong> was written by Ryan Finnie &lt;<a href="mailto:ryan@finnie.org">ryan@finnie.org</a>&gt;.  vanityhash 
was inspired by Seth David Schoen's 2003 program, hash_search.</p>

</body>

</html>
